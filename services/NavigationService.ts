import * as Location from "expo-location";
import { Vibration } from "react-native";
import { NavigationState, NavigationStep } from "../types/RouteTypes";
import { NavigationInstructionService } from "./NavigationInstructionService";
import { LastTripStorage, LastTripData } from "./LastTripStorage";

class NavigationService {
  private lastNotificationTime: number = 0;
  private navigationState: NavigationState = {
    isNavigating: false,
    currentStepIndex: 0,
    steps: [],
    remainingDistance: 0,
    remainingDuration: 0,
    nextStep: undefined,
    distanceToNextStep: 0,
    currentLocation: null,
    completedRouteCoordinates: [],
    remainingRouteCoordinates: [],
    progressPercentage: 0,
    hasStartedMoving: false,
  };

  private locationSubscription: Location.LocationSubscription | null = null;
  private listeners: ((state: NavigationState) => void)[] = [];
  private routeService: any = null; // R√©f√©rence au service de route
  private currentMode: string = "driving";
  private lastRouteCheck: number = 0; // Timestamp du dernier check de route
  private routeCoordinates: number[] = []; // Coordonn√©es compl√®tes de la route
  private lastTripDestination: {
    latitude: number;
    longitude: number;
    name?: string;
  } | null = null;
  private initialLocation: { latitude: number; longitude: number } | null =
    null; // Position de d√©part
  private movementThreshold: number = 20; // Distance minimale pour consid√©rer qu'on a commenc√© √† bouger (m√®tres)

  // Nouveau syst√®me pour √©viter les changements d'√©tapes trop fr√©quents
  private lastStepChangeTime: number = 0;
  private stepChangeMinInterval: number = 3000; // 3 secondes minimum entre changements d'√©tapes
  private stepToleranceDistance: number = 50; // 50 m√®tres de tol√©rance pour √©viter les oscillations

  // D√©marrer la navigation avec les √©tapes de route
  async startNavigation(
    routeSteps: NavigationStep[],
    routeService?: any,
    mode: string = "driving",
    fullRouteCoordinates?: number[],
    destinationInfo?: { latitude: number; longitude: number; name?: string }
  ) {
    // Vibration pour confirmer le d√©but de navigation
    Vibration.vibrate(150);

    this.routeService = routeService;
    this.currentMode = mode;
    this.routeCoordinates = fullRouteCoordinates || [];
    this.lastTripDestination = destinationInfo || null;

    // Sauvegarder le trajet en cours
    if (routeSteps.length > 0 && destinationInfo) {
      await LastTripStorage.save({
        destination: destinationInfo,
        mode,
        routeSteps,
        fullRouteCoordinates: fullRouteCoordinates || [],
      });
    }

    // Obtenir la position actuelle pour √©tablir le point de d√©part
    let currentLocation: { latitude: number; longitude: number } | null = null;
    let initialStepIndex = 0;

    try {
      const locationResult = await Location.getCurrentPositionAsync({
        accuracy: Location.Accuracy.BestForNavigation,
      });
      currentLocation = {
        latitude: locationResult.coords.latitude,
        longitude: locationResult.coords.longitude,
      };
      this.initialLocation = currentLocation;

      // üöÄ AM√âLIORATION : D√©tecter imm√©diatement la bonne √©tape de d√©part
      // Si l'utilisateur est d√©j√† en mouvement, trouver l'√©tape la plus proche
      if (routeSteps.length > 0) {
        const closestStepIndex = NavigationInstructionService.findClosestStep(
          currentLocation,
          routeSteps
        );

        // Si on d√©tecte qu'on est plus proche d'une √©tape suivante, d√©marrer depuis cette √©tape
        if (closestStepIndex > 0) {
          // V√©rifier si on est vraiment pass√© la premi√®re √©tape (pas juste √† c√¥t√©)
          const distanceToFirst = this.calculateDistanceToStep(
            currentLocation,
            routeSteps[0]
          );
          const distanceToClosest = this.calculateDistanceToStep(
            currentLocation,
            routeSteps[closestStepIndex]
          );

          // Si on est significativement plus proche de l'√©tape trouv√©e ET qu'on a probablement d√©pass√© la premi√®re
          if (
            distanceToClosest < distanceToFirst - 100 &&
            distanceToFirst > 150
          ) {
            initialStepIndex = closestStepIndex;
          }
        }
      }
    } catch (error) {
      console.warn("Impossible d'obtenir la position de d√©part:", error);
    }

    this.navigationState = {
      ...this.navigationState,
      isNavigating: true,
      currentStepIndex: initialStepIndex, // Utiliser l'√©tape d√©tect√©e au lieu de 0
      steps: routeSteps,
      remainingDistance: this.calculateTotalDistance(routeSteps),
      remainingDuration: this.calculateTotalDuration(routeSteps),
      nextStep: routeSteps[initialStepIndex], // Commencer √† la bonne √©tape
      distanceToNextStep: routeSteps[initialStepIndex]?.distance || 0,
      currentLocation: currentLocation,
      completedRouteCoordinates: [],
      remainingRouteCoordinates: this.convertRouteCoordinatesToPairs(
        fullRouteCoordinates || []
      ),
      progressPercentage: 0,
      hasStartedMoving: initialStepIndex > 0, // Si on d√©marre plus loin, on a d√©j√† boug√©
    };

    this.startLocationTracking();
    this.notifyListeners();
  }

  // Arr√™ter la navigation
  async stopNavigation() {
    // Supprimer le trajet sauvegard√© (trajet termin√© ou annul√©)
    await LastTripStorage.clear();
    this.navigationState = {
      ...this.navigationState,
      isNavigating: false,
      currentStepIndex: 0,
      steps: [],
      remainingDistance: 0,
      remainingDuration: 0,
      nextStep: undefined,
      distanceToNextStep: 0,
      completedRouteCoordinates: [],
      remainingRouteCoordinates: [],
      progressPercentage: 0,
      hasStartedMoving: false,
    };

    // R√©initialiser les variables internes
    this.initialLocation = null;

    this.stopLocationTracking();
    this.notifyListeners();
  }

  // D√©marrer le suivi de position
  private async startLocationTracking() {
    try {
      const { status } = await Location.requestForegroundPermissionsAsync();
      if (status !== "granted") {
        console.error("Permission de localisation refus√©e");
        return;
      }

      this.locationSubscription = await Location.watchPositionAsync(
        {
          accuracy: Location.Accuracy.BestForNavigation,
          timeInterval: 1000, // Mise √† jour chaque seconde
          distanceInterval: 5, // Ou tous les 5 m√®tres
        },
        (location) => {
          this.updateCurrentLocation({
            latitude: location.coords.latitude,
            longitude: location.coords.longitude,
          });
        }
      );
    } catch (error) {
      console.error("Erreur lors du d√©marrage du suivi GPS:", error);
    }
  }

  // Arr√™ter le suivi de position
  private stopLocationTracking() {
    if (this.locationSubscription) {
      this.locationSubscription.remove();
      this.locationSubscription = null;
    }
  }

  // Mettre √† jour la position actuelle et recalculer la navigation
  private async updateCurrentLocation(location: {
    latitude: number;
    longitude: number;
  }) {
    this.navigationState.currentLocation = location;

    if (this.navigationState.isNavigating && this.navigationState.nextStep) {
      // V√©rifier si l'utilisateur a commenc√© √† bouger (pour √©viter les faux sauts d'√©tapes)
      if (!this.navigationState.hasStartedMoving && this.initialLocation) {
        const distanceFromStart = this.calculateDistance(
          this.initialLocation.latitude,
          this.initialLocation.longitude,
          location.latitude,
          location.longitude
        );

        if (distanceFromStart > this.movementThreshold) {
          this.navigationState.hasStartedMoving = true;
        }
      }

      // Mettre √† jour la progression de la route
      this.updateRouteProgress(location);

      // D√©tecter si l'utilisateur a avanc√© dans l'itin√©raire (seulement s'il a commenc√© √† bouger)
      if (this.navigationState.hasStartedMoving) {
        const closestStepIndex = NavigationInstructionService.findClosestStep(
          location,
          this.navigationState.steps
        );
        const now = Date.now();

        // Si l'utilisateur est plus proche d'une √©tape diff√©rente (en avant ou en arri√®re), passer √† cette √©tape
        if (
          closestStepIndex !== this.navigationState.currentStepIndex &&
          closestStepIndex >= 0
        ) {
          // Calculer la distance actuelle √† l'√©tape sugg√©r√©e pour √©viter les changements trop fr√©quents
          const currentStep =
            this.navigationState.steps[this.navigationState.currentStepIndex];
          const suggestedStep = this.navigationState.steps[closestStepIndex];

          let shouldChangeStep = false;

          // V√©rifier si assez de temps s'est √©coul√© depuis le dernier changement
          const timeSinceLastChange = now - this.lastStepChangeTime;
          if (timeSinceLastChange >= this.stepChangeMinInterval) {
            // Calculer les distances aux deux √©tapes pour s'assurer que le changement est justifi√©
            if (currentStep?.coordinates && suggestedStep?.coordinates) {
              const distanceToCurrentStep = this.calculateDistanceToStep(
                location,
                currentStep
              );
              const distanceToSuggestedStep = this.calculateDistanceToStep(
                location,
                suggestedStep
              );

              // üöÄ AM√âLIORATION : Logique plus intelligente pour √©viter les blocages

              // Si on avance (index plus √©lev√©), √™tre moins strict
              if (closestStepIndex > this.navigationState.currentStepIndex) {
                // Pour avancer, v√©rifier qu'on est vraiment plus proche de la nouvelle √©tape
                if (
                  distanceToSuggestedStep < distanceToCurrentStep ||
                  distanceToCurrentStep > 200
                ) {
                  shouldChangeStep = true;
                }
              }
              // Si on recule (index plus faible), √™tre plus strict
              else if (
                closestStepIndex < this.navigationState.currentStepIndex
              ) {
                // Pour reculer, v√©rifier qu'il y a une vraie diff√©rence de distance
                if (
                  distanceToSuggestedStep <
                  distanceToCurrentStep - this.stepToleranceDistance * 2
                ) {
                  shouldChangeStep = true;
                }
              }
            } else {
              // Si on n'a pas de coordonn√©es d√©taill√©es, faire le changement prudemment
              // Seulement si on avance ou si on est tr√®s loin de l'√©tape actuelle
              if (closestStepIndex > this.navigationState.currentStepIndex) {
                shouldChangeStep = true;
              }
            }
          }

          if (shouldChangeStep) {
            this.navigationState.currentStepIndex = closestStepIndex;
            this.navigationState.nextStep =
              this.navigationState.steps[closestStepIndex];
            this.navigationState.distanceToNextStep =
              this.navigationState.nextStep?.distance || 0;
            this.lastStepChangeTime = now;

            // Vibration pour indiquer le changement d'√©tape
            Vibration.vibrate([100, 50, 100, 50, 100]);
          }
        }
      }

      // V√©rifier si on a quitt√© la route (tous les 10 secondes pour √©viter trop de requ√™tes)
      const now = Date.now();
      if (this.routeService && now - this.lastRouteCheck > 10000) {
        this.lastRouteCheck = now;
        const needsRecalculation =
          await this.routeService.recalculateIfOffRoute(
            { latitude: location.latitude, longitude: location.longitude },
            this.currentMode
          );
        if (needsRecalculation) {
          // Vibration pour indiquer que la route a √©t√© recalcul√©e
          Vibration.vibrate([50, 50, 50]); // Triple vibration courte pour recalcul
          // IMPORTANT: R√©cup√©rer les nouvelles donn√©es de route directement depuis l'API
          if (this.lastTripDestination) {
            try {
              // Recalculer la route depuis la position actuelle vers la destination
              const routeCalculated = await this.routeService.getHybridRoute(
                { latitude: location.latitude, longitude: location.longitude },
                this.lastTripDestination,
                this.currentMode
              );

              if (routeCalculated) {
                // Les nouvelles coordonn√©es sont automatiquement mises √† jour dans routeService
                // Maintenant on a besoin de r√©cup√©rer les nouvelles √©tapes depuis l'API OSRM
                const newSteps = await this.fetchNavigationStepsFromAPI(
                  {
                    latitude: location.latitude,
                    longitude: location.longitude,
                  },
                  this.lastTripDestination,
                  this.currentMode
                );

                if (newSteps && newSteps.length > 0) {
                  // Mettre √† jour les √©tapes de navigation
                  this.navigationState.steps = newSteps;
                  this.navigationState.currentStepIndex = 0; // Repartir de la premi√®re √©tape
                  this.navigationState.nextStep = newSteps[0];
                  this.navigationState.distanceToNextStep =
                    newSteps[0]?.distance || 0;
                  this.navigationState.remainingDistance =
                    this.calculateTotalDistance(newSteps);
                  this.navigationState.remainingDuration =
                    this.calculateTotalDuration(newSteps);
                  this.routeCoordinates =
                    this.routeService.routeCoords
                      ?.map((coord: any) => [coord.longitude, coord.latitude])
                      .flat() || [];

                  // Sauvegarder la nouvelle route dans le storage
                  await LastTripStorage.save({
                    destination: this.lastTripDestination,
                    mode: this.currentMode,
                    routeSteps: newSteps,
                    fullRouteCoordinates: this.routeCoordinates,
                  });
                } else {
                  console.warn(
                    "üîÑ Failed to get navigation steps from API after recalculation"
                  );
                }
              }
            } catch (error) {
              console.error("üîÑ Error during route recalculation:", error);
            }
          }

          return;
        }
      }

      // Calculer la distance √† la prochaine √©tape
      const distanceToNext = this.calculateDistance(
        location.latitude,
        location.longitude,
        this.navigationState.nextStep.coordinates[1],
        this.navigationState.nextStep.coordinates[0]
      );

      this.navigationState.distanceToNextStep = distanceToNext;

      // V√©rifier si on doit passer √† l'√©tape suivante (dans un rayon de 30m)
      if (
        distanceToNext < 30 &&
        this.navigationState.currentStepIndex <
          this.navigationState.steps.length - 1
      ) {
        this.advanceToNextStep();
      }

      // Recalculer les distances et temps restants
      this.updateRemainingStats();

      this.notifyListeners();
    }
  }

  // Passer √† l'√©tape suivante
  private async advanceToNextStep() {
    const nextIndex = this.navigationState.currentStepIndex + 1;

    if (nextIndex < this.navigationState.steps.length) {
      // Vibration pour indiquer qu'on passe √† l'√©tape suivante
      Vibration.vibrate([100, 50, 100]); // Double vibration pour intersection/changement de direction

      this.navigationState.currentStepIndex = nextIndex;
      this.navigationState.nextStep = this.navigationState.steps[nextIndex];
      this.navigationState.distanceToNextStep =
        this.navigationState.nextStep?.distance || 0;

      // Mettre √† jour la notification pour la nouvelle √©tape (imm√©diat, pas de throttle)
      this.lastNotificationTime = Date.now();
    } else {
      // Vibration pour destination atteinte
      Vibration.vibrate([200, 100, 200, 100, 200]); // S√©quence distinctive pour arriv√©e

      // Navigation termin√©e
      this.stopNavigation();
    }
  }

  // Mettre √† jour les statistiques restantes
  private updateRemainingStats() {
    const remainingSteps = this.navigationState.steps.slice(
      this.navigationState.currentStepIndex
    );
    this.navigationState.remainingDistance =
      this.calculateTotalDistance(remainingSteps) +
      this.navigationState.distanceToNextStep;
    this.navigationState.remainingDuration =
      this.calculateTotalDuration(remainingSteps);
  }

  // Calculer la distance totale des √©tapes
  private calculateTotalDistance(steps: NavigationStep[]): number {
    return steps.reduce((total, step) => total + step.distance, 0);
  }

  // Calculer la dur√©e totale des √©tapes
  private calculateTotalDuration(steps: NavigationStep[]): number {
    return steps.reduce((total, step) => total + step.duration, 0);
  }

  // Calculer la distance entre deux points (formule haversine)
  private calculateDistance(
    lat1: number,
    lon1: number,
    lat2: number,
    lon2: number
  ): number {
    const R = 6371e3; // Rayon de la Terre en m√®tres
    const œÜ1 = (lat1 * Math.PI) / 180;
    const œÜ2 = (lat2 * Math.PI) / 180;
    const ŒîœÜ = ((lat2 - lat1) * Math.PI) / 180;
    const ŒîŒª = ((lon2 - lon1) * Math.PI) / 180;

    const a =
      Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +
      Math.cos(œÜ1) * Math.cos(œÜ2) * Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

    return R * c;
  }

  // R√©cup√©rer les √©tapes de navigation directement depuis l'API OSRM
  private async fetchNavigationStepsFromAPI(
    start: { latitude: number; longitude: number },
    end: { latitude: number; longitude: number },
    mode: string
  ): Promise<NavigationStep[]> {
    try {
      const osrmMode =
        mode === "bicycling" ? "bike" : mode === "walking" ? "foot" : "driving";
      const url = `https://router.project-osrm.org/route/v1/${osrmMode}/${start.longitude},${start.latitude};${end.longitude},${end.latitude}?overview=full&geometries=geojson&steps=true`;
      const response = await fetch(url);
      const data = await response.json();

      if (data.routes && data.routes.length > 0) {
        // Utiliser la m√©thode existante pour convertir les donn√©es OSRM
        const steps = this.convertRouteToNavigationSteps(data);
        return steps;
      } else {
        console.warn("üîÑ No routes found in OSRM response");
        return [];
      }
    } catch (error) {
      console.error("üîÑ Error fetching navigation steps from OSRM:", error);
      return [];
    }
  }

  // Convertir les donn√©es de route en √©tapes de navigation
  convertRouteToNavigationSteps(routeData: any): NavigationStep[] {
    // Cette fonction doit √™tre adapt√©e selon le format des donn√©es de votre API de routing
    // Exemple avec les donn√©es OSRM ou OpenRouteService
    const steps: NavigationStep[] = [];
    if (routeData.routes && routeData.routes[0] && routeData.routes[0].legs) {
      routeData.routes[0].legs.forEach((leg: any) => {
        if (leg.steps) {
          leg.steps.forEach((step: any, index: number) => {
            const navigationStep = {
              instruction:
                step.maneuver?.instruction ||
                `Continuer sur ${step.name || "la route"}`,
              distance: step.distance || 0,
              duration: step.duration || 0,
              maneuver: step.maneuver?.type || "straight",
              coordinates: step.maneuver?.location || [0, 0],
              direction: this.getDirection(step.maneuver?.bearing_after),
              streetName: step.name || "",
              // Ajouter les donn√©es OSRM compl√®tes pour une meilleure analyse
              osrmModifier: step.maneuver?.modifier,
              osrmInstruction: step.maneuver?.instruction,
              bearingBefore: step.maneuver?.bearing_before,
              bearingAfter: step.maneuver?.bearing_after,
            };

            steps.push(navigationStep);
          });
        }
      });
    }

    return steps;
  }

  // Convertir l'angle en direction
  private getDirection(bearing?: number): string {
    if (bearing === undefined) return "";

    const directions = ["N", "NE", "E", "SE", "S", "SW", "W", "NW"];
    const index = Math.round(bearing / 45) % 8;
    return directions[index];
  }

  // Obtenir le maneuver icon
  getManeuverIcon(maneuver: string): string {
    const icons: { [key: string]: string } = {
      "turn-straight": "straight",
      "turn-slight-right": "turn-slight-right",
      "turn-right": "turn-right",
      "turn-sharp-right": "turn-sharp-right",
      "turn-slight-left": "turn-slight-left",
      "turn-left": "turn-left",
      "turn-sharp-left": "turn-sharp-left",
      uturn: "u-turn-right",
      arrive: "flag",
      depart: "play-arrow",
      merge: "merge-type",
      "on-ramp": "ramp-right",
      "off-ramp": "ramp-left",
      roundabout: "roundabout-right",
    };

    return icons[maneuver] || "straight";
  }

  // Convertir les coordonn√©es de route en paires [longitude, latitude]
  private convertRouteCoordinatesToPairs(
    coordinates: number[]
  ): [number, number][] {
    const pairs: [number, number][] = [];
    for (let i = 0; i < coordinates.length; i += 2) {
      if (i + 1 < coordinates.length) {
        pairs.push([coordinates[i], coordinates[i + 1]]);
      }
    }
    return pairs;
  }

  // Mettre √† jour la progression de la route
  private updateRouteProgress(currentLocation: {
    latitude: number;
    longitude: number;
  }) {
    if (
      !this.navigationState.remainingRouteCoordinates ||
      this.navigationState.remainingRouteCoordinates.length === 0
    ) {
      return;
    }

    // Trouver le point le plus proche sur la route
    let closestPointIndex = 0;
    let minDistance = Infinity;

    this.navigationState.remainingRouteCoordinates.forEach((coord, index) => {
      const distance = this.calculateDistance(
        currentLocation.latitude,
        currentLocation.longitude,
        coord[1], // latitude
        coord[0] // longitude
      );

      if (distance < minDistance) {
        minDistance = distance;
        closestPointIndex = index;
      }
    });

    // Diviser la route en partie compl√©t√©e et partie restante
    const allRouteCoords = this.convertRouteCoordinatesToPairs(
      this.routeCoordinates
    );
    const totalPoints = allRouteCoords.length;
    const remainingPoints =
      this.navigationState.remainingRouteCoordinates.length;
    const completedPoints = totalPoints - remainingPoints + closestPointIndex;

    // Mettre √† jour les coordonn√©es de progression
    this.navigationState.completedRouteCoordinates = allRouteCoords.slice(
      0,
      completedPoints
    );
    this.navigationState.remainingRouteCoordinates =
      allRouteCoords.slice(completedPoints);

    // Calculer le pourcentage de progression
    if (totalPoints > 0) {
      this.navigationState.progressPercentage = Math.min(
        100,
        Math.max(0, (completedPoints / totalPoints) * 100)
      );
    }
  }

  // Obtenir les coordonn√©es de la route compl√©t√©e (pour l'affichage)
  getCompletedRouteCoordinates(): [number, number][] {
    return this.navigationState.completedRouteCoordinates || [];
  }

  // Obtenir les coordonn√©es de la route restante (pour l'affichage)
  getRemainingRouteCoordinates(): [number, number][] {
    return this.navigationState.remainingRouteCoordinates || [];
  }

  // Calculer la distance minimale entre l'utilisateur et une √©tape de navigation
  private calculateDistanceToStep(
    userLocation: { latitude: number; longitude: number },
    step: NavigationStep
  ): number {
    if (!step.coordinates || step.coordinates.length < 2) {
      return Infinity;
    }

    let minDistance = Infinity;

    // V√©rifier le point de d√©but
    const stepStart = {
      latitude: step.coordinates[1],
      longitude: step.coordinates[0],
    };

    // V√©rifier le point de fin
    const stepEnd = {
      latitude: step.coordinates[step.coordinates.length - 1],
      longitude: step.coordinates[step.coordinates.length - 2],
    };

    const distanceToStart = this.calculateDistance(
      userLocation.latitude,
      userLocation.longitude,
      stepStart.latitude,
      stepStart.longitude
    );
    const distanceToEnd = this.calculateDistance(
      userLocation.latitude,
      userLocation.longitude,
      stepEnd.latitude,
      stepEnd.longitude
    );

    minDistance = Math.min(distanceToStart, distanceToEnd);

    // Pour les √©tapes plus longues, v√©rifier aussi quelques points interm√©diaires
    if (step.coordinates.length > 4) {
      const midIndex = Math.floor((step.coordinates.length - 2) / 2);
      const stepMid = {
        latitude: step.coordinates[midIndex + 1],
        longitude: step.coordinates[midIndex],
      };
      const distanceToMid = this.calculateDistance(
        userLocation.latitude,
        userLocation.longitude,
        stepMid.latitude,
        stepMid.longitude
      );
      minDistance = Math.min(minDistance, distanceToMid);
    }

    return minDistance;
  }

  // Obtenir le pourcentage de progression
  getProgressPercentage(): number {
    return this.navigationState.progressPercentage || 0;
  }

  // √âcouter les changements d'√©tat
  addListener(callback: (state: NavigationState) => void) {
    this.listeners.push(callback);
  }

  // Supprimer un listener
  removeListener(callback: (state: NavigationState) => void) {
    this.listeners = this.listeners.filter((listener) => listener !== callback);
  }

  // Notifier tous les listeners
  private notifyListeners() {
    this.listeners.forEach((listener) => listener({ ...this.navigationState }));
  }

  // Obtenir l'√©tat actuel
  getCurrentState(): NavigationState {
    return { ...this.navigationState };
  }
}

export default new NavigationService();
