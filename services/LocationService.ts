import { useEffect, useRef, useState } from "react";
import * as Location from "expo-location";
import { Magnetometer } from "expo-sensors";
import { Animated, Platform } from "react-native";

export interface LocationService {
  location: Location.LocationObjectCoords | null;
  heading: number;
  headingAnimated: Animated.Value;
  headingAnim: Animated.Value;
  currentHeading: number;
  startLocationTracking: () => Promise<void>;
  stopLocationTracking: () => void;
  requestLocationPermission: () => Promise<boolean>;
}

class HeadingFilter {
  private filteredHeading = 0;
  private alpha = 0.15;
  private threshold = 1.5;
  private initialized = false;

  update(newHeading: number): number {
    if (!this.initialized) {
      this.filteredHeading = newHeading;
      this.initialized = true;
      return this.filteredHeading;
    }

    const diff = this.angleDifference(newHeading, this.filteredHeading);

    if (Math.abs(diff) > this.threshold) {
      this.filteredHeading = this.normalizeAngle(
        this.filteredHeading + diff * this.alpha
      );
    }

    return this.filteredHeading;
  }

  private angleDifference(a: number, b: number): number {
    let diff = a - b;
    if (diff > 180) diff -= 360;
    else if (diff < -180) diff += 360;
    return diff;
  }

  private normalizeAngle(angle: number): number {
    return ((angle % 360) + 360) % 360;
  }

  reset(heading: number) {
    this.filteredHeading = heading;
    this.initialized = true;
  }
}

export function useLocationService(): LocationService {
  const [location, setLocation] =
    useState<Location.LocationObjectCoords | null>(null);
  const [heading, setHeading] = useState(0);
  const headingAnimated = useRef(new Animated.Value(0)).current;

  const headingFilter = useRef(new HeadingFilter()).current;
  const locationSub = useRef<Location.LocationSubscription | null>(null);
  const magnetometerSub = useRef<any>(null);
  const lastUpdate = useRef(0);
  const animationInProgress = useRef(false);
  const lastAnimatedValue = useRef(0);

  const requestLocationPermission = async (): Promise<boolean> => {
    try {
      const { status } = await Location.requestForegroundPermissionsAsync();
      return status === "granted";
    } catch {
      return false;
    }
  };

  function calculateHeading(x: number, y: number, z: number): number {
    // Calculer l'angle avec atan2 et inverser x pour corriger est/ouest
    let heading = Math.atan2(-x, y) * (180 / Math.PI);

    // Normaliser pour avoir 0-360¬∞
    heading = (heading + 360) % 360;

    return heading;
  }

  function updateHeadingSmooth(newHeading: number) {
    const now = Date.now();

    if (now - lastUpdate.current < 100) return; // Augmenter l'intervalle √† 100ms
    lastUpdate.current = now;

    const filteredHeading = headingFilter.update(newHeading);
    
    const currentAnimatedValue = lastAnimatedValue.current;
    let targetValue = filteredHeading;

    // Trouver le chemin le plus court pour l'animation
    let diff1 = targetValue - currentAnimatedValue;
    let diff2 = targetValue - currentAnimatedValue + 360;
    let diff3 = targetValue - currentAnimatedValue - 360;

    let bestDiff = diff1;
    if (Math.abs(diff2) < Math.abs(bestDiff)) bestDiff = diff2;
    if (Math.abs(diff3) < Math.abs(bestDiff)) bestDiff = diff3;

    const newAnimatedValue = currentAnimatedValue + bestDiff;

    if (Math.abs(bestDiff) < 2) return; // R√©duire le seuil de 1 √† 2 degr√©s

    console.log("üß≠ Mise √† jour du cap:", filteredHeading.toFixed(1), "¬∞");
    setHeading(filteredHeading);
    lastAnimatedValue.current = newAnimatedValue;

    if (!animationInProgress.current) {
      animationInProgress.current = true;
      Animated.timing(headingAnimated, {
        toValue: newAnimatedValue,
        duration: 300, // Augmenter la dur√©e pour une animation plus fluide
        useNativeDriver: true,
      }).start(() => {
        animationInProgress.current = false;
      });
    }
  }

  const startLocationTracking = async () => {
    console.log("üîÑ D√©marrage du service de localisation...");
    
    const granted = await requestLocationPermission();
    if (!granted) {
      console.error("‚ùå Permissions de localisation refus√©es");
      return;
    }

    try {
      console.log("üîÑ Obtention de la position initiale...");
      
      // Essayer plusieurs modes pour obtenir la position initiale
      let initialPosition;
      const accuracyModes = [
        { name: "BestForNavigation", mode: Location.Accuracy.BestForNavigation },
        { name: "High", mode: Location.Accuracy.High },
        { name: "Balanced", mode: Location.Accuracy.Balanced },
        { name: "Low", mode: Location.Accuracy.Low },
      ];
      
      for (const { name, mode } of accuracyModes) {
        try {
          console.log(`üîÑ Tentative avec ${name}...`);
          initialPosition = await Location.getCurrentPositionAsync({
            accuracy: mode,
            timeInterval: 5000,
          });
          console.log(`‚úÖ Position initiale obtenue avec ${name}:`, initialPosition.coords);
          setLocation(initialPosition.coords);
          break;
        } catch (modeError) {
          console.log(`‚ùå √âchec avec ${name}:`, modeError.message);
          if (name === "Low") {
            // Si m√™me le mode Low √©choue, essayer avec la derni√®re position connue
            try {
              const lastKnown = await Location.getLastKnownPositionAsync({
                maxAge: 600000, // 10 minutes
              });
              if (lastKnown) {
                console.log("üìç Utilisation de la derni√®re position connue:", lastKnown.coords);
                setLocation(lastKnown.coords);
                initialPosition = lastKnown;
              }
            } catch (lastKnownError) {
              console.error("‚ùå Impossible d'obtenir la derni√®re position connue:", lastKnownError);
            }
          }
        }
      }

      if (!initialPosition) {
        throw new Error("Impossible d'obtenir une position avec tous les modes de pr√©cision");
      }

      console.log("üîÑ D√©marrage du suivi de position...");
      locationSub.current = await Location.watchPositionAsync(
        {
          accuracy: Location.Accuracy.BestForNavigation,
          distanceInterval: 1,
          timeInterval: 1000,
        },
        (loc) => {
          console.log("üìç Nouvelle position:", loc.coords.latitude, loc.coords.longitude);
          setLocation(loc.coords);
        }
      );

      console.log("üîÑ D√©marrage du suivi de cap...");
      
      // V√©rifier la disponibilit√© du magn√©tom√®tre
      const isAvailable = await Magnetometer.isAvailableAsync();
      console.log("üß≠ Magn√©tom√®tre disponible:", isAvailable);
      
      if (!isAvailable) {
        console.warn("‚ö†Ô∏è Magn√©tom√®tre non disponible sur cet appareil");
        // Continuer sans le cap magn√©tique
        return;
      }

      Magnetometer.setUpdateInterval(100); // R√©duire la fr√©quence √† 100ms pour de meilleures performances

      magnetometerSub.current = Magnetometer.addListener(({ x, y, z }) => {
        const rawHeading = calculateHeading(x, y, z);
        updateHeadingSmooth(rawHeading);
      });
      
      console.log("‚úÖ Service de localisation d√©marr√© avec succ√®s");
    } catch (error) {
      console.error("‚ùå Erreur lors du d√©marrage du suivi:", error);
      
      // Essayer une approche de r√©cup√©ration avec un mode plus permissif
      try {
        console.log("üîÑ Tentative de r√©cup√©ration avec mode permissif...");
        const fallbackPosition = await Location.getCurrentPositionAsync({
          accuracy: Location.Accuracy.Lowest,
          timeInterval: 15000, // 15 secondes de timeout
        });
        
        console.log("‚úÖ Position obtenue en mode de r√©cup√©ration:", fallbackPosition.coords);
        setLocation(fallbackPosition.coords);
        
        // Essayer de d√©marrer le suivi avec des param√®tres moins exigeants
        locationSub.current = await Location.watchPositionAsync(
          {
            accuracy: Location.Accuracy.Balanced,
            distanceInterval: 5,
            timeInterval: 2000,
          },
          (loc) => setLocation(loc.coords)
        );
        
        console.log("‚úÖ Suivi de position d√©marr√© en mode r√©cup√©ration");
      } catch (fallbackError) {
        console.error("‚ùå √âchec de la r√©cup√©ration:", fallbackError);
        
        // Dernier recours: essayer de d√©marrer le suivi sans position initiale
        try {
          console.log("üîÑ Tentative de d√©marrage du suivi sans position initiale...");
          locationSub.current = await Location.watchPositionAsync(
            {
              accuracy: Location.Accuracy.Low,
              distanceInterval: 10,
              timeInterval: 5000,
            },
            (loc) => {
              console.log("üìç Position obtenue via le suivi:", loc.coords);
              setLocation(loc.coords);
            }
          );
          
          console.log("‚úÖ Suivi d√©marr√© sans position initiale - en attente de la premi√®re position...");
          
          // D√©marrer le magn√©tom√®tre m√™me sans position initiale
          console.log("üß≠ D√©marrage du magn√©tom√®tre en mode r√©cup√©ration...");
          
          const isAvailable = await Magnetometer.isAvailableAsync();
          console.log("üß≠ Magn√©tom√®tre disponible (r√©cup√©ration):", isAvailable);
          
          if (isAvailable) {
            Magnetometer.setUpdateInterval(100);
            magnetometerSub.current = Magnetometer.addListener(({ x, y, z }) => {
              const rawHeading = calculateHeading(x, y, z);
              updateHeadingSmooth(rawHeading);
            });
          } else {
            console.warn("‚ö†Ô∏è Magn√©tom√®tre non disponible - pas de cap magn√©tique");
          }
          
          return; // Sortir sans erreur
        } catch (watchError) {
          console.error("‚ùå Impossible de d√©marrer m√™me le suivi:", watchError);
        }
        
        // L'erreur sera visible dans l'interface utilisateur
        throw new Error(`Impossible d'obtenir votre position. Essayez de red√©marrer l'application ou v√©rifiez que d'autres applications peuvent acc√©der √† votre GPS. Erreur technique: ${error.message}`);
      }
    }
  };

  const stopLocationTracking = () => {
    locationSub.current?.remove();
    locationSub.current = null;

    magnetometerSub.current?.remove();
    magnetometerSub.current = null;
  };

  useEffect(() => {
    // D√©marrer le magn√©tom√®tre imm√©diatement au montage du composant
    const initMagnetometer = async () => {
      try {
        const isAvailable = await Magnetometer.isAvailableAsync();
        console.log("üß≠ Initialisation du magn√©tom√®tre:", isAvailable);
        
        if (isAvailable) {
          Magnetometer.setUpdateInterval(100);
          magnetometerSub.current = Magnetometer.addListener(({ x, y, z }) => {
            const rawHeading = calculateHeading(x, y, z);
            updateHeadingSmooth(rawHeading);
          });
          console.log("‚úÖ Magn√©tom√®tre d√©marr√© avec succ√®s");
        } else {
          console.warn("‚ö†Ô∏è Magn√©tom√®tre non disponible sur cet appareil");
        }
      } catch (error) {
        console.error("‚ùå Erreur lors de l'initialisation du magn√©tom√®tre:", error);
      }
    };

    initMagnetometer();

    return () => stopLocationTracking();
  }, []);

  return {
    location,
    heading,
    headingAnimated,
    headingAnim: headingAnimated,
    currentHeading: heading,
    startLocationTracking,
    stopLocationTracking,
    requestLocationPermission,
  };
}
